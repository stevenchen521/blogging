{
  
    
        "post0": {
            "title": "AWS VPC Exercise",
            "content": "Prerequisite . Create a free AWS Account. | Download the exercise code | Install AWS Cli and config the aws configure | .",
            "url": "https://stevenchen521.github.io/blogging/aws/2021/12/16/aws_vpc_exercise.html",
            "relUrl": "/aws/2021/12/16/aws_vpc_exercise.html",
            "date": " ‚Ä¢ Dec 16, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Upsert DataFrame to MongoDB",
            "content": "Requirement . Let&#39;s say we have a DataFrame. We want to &#39;upsert&#39;(Insert/update) the MongoDB collection with rows in DataFrame. More specifically, for the rows that don&#39;t exist we do the creation, otherwise the update should be performed. . def show_collection(collection): display(DataFrame([row for row in collection.find()])) . Setup Cloud MongoDB for Free . Setup a free cloud based MongoDB database here. . Connect to the database and create the &#39;test&#39; database and &#39;employee&#39; collection. . DB_NAME = &#39;test&#39; COLLECTION_NAME = &#39;employee&#39; . client = MongoClient(CONN_STR) client.drop_database(DB_NAME) # clear the database db = client[DB_NAME] # switch database collection = db[COLLECTION_NAME] # get the collection . now = datetime.now() emplyee = [[&#39;user1&#39;,25,&#39;male&#39;, now],[&#39;user2&#39;,55,&#39;male&#39;, now],[&#39;user3&#39;,43,&#39;male&#39;, now]] df_emplyee = DataFrame(emplyee, columns=[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;, &#39;lastModifiedAt&#39;]) df_emplyee = df_emplyee[[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;]] . Prepare a test DataFrame df_emplyee that contains three columns: . name | age | sex | . df_emplyee . name age sex . 0 user1 | 25 | male | . 1 user2 | 55 | male | . 2 user3 | 43 | male | . Once the records are inserted to the collection, we get the _id column for every row. &#39;_id&#39; column is a potentially a good shard key used by MongoDB cluster. . collection.insert_many(df_emplyee.to_dict(&quot;records&quot;)) show_collection(collection) . _id name age sex . 0 61b369d876faf969a2fb0ac9 | user1 | 25 | male | . 1 61b369d876faf969a2fb0aca | user2 | 55 | male | . 2 61b369d876faf969a2fb0acb | user3 | 43 | male | . Update . Let&#39;s do the update. Change the age of user1 to 32 with update_one method. . filter parameter get the rows that need update. | $set flag is to update the columns specified. | $currentDate here is to update lastModifiedAt column with the current time. | . myquery = { &quot;name&quot;: &quot;user1&quot; } newvalues = { &quot;$set&quot;: { &quot;age&quot;: &quot;32&quot; }, &quot;$currentDate&quot;: {&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} } res = collection.update_one(filter=myquery, update=newvalues) . show_collection(collection) . _id name age sex lastModifiedAt . 0 61b369d876faf969a2fb0ac9 | user1 | 32 | male | 2021-12-10 14:53:12.765 | . 1 61b369d876faf969a2fb0aca | user2 | 55 | male | NaT | . 2 61b369d876faf969a2fb0acb | user3 | 43 | male | NaT | . Upsert . As the name suggests &#39;upsert&#39; means update/insert records based on the specified filters. For intansce, in the following first example, &#39;user1&#39; exists in the collection. The &#39;upsert&#39; performs the update. In the second example, user4 doesn&#39;t exist and it is inserted to the collection. . collection.update_one({&quot;name&quot;:&quot;user1&quot;}, {&quot;$set&quot;:{&quot;age&quot;:32}, &quot;$currentDate&quot;: {&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b369d876faf969a2fb0ac9 | user1 | 32 | male | 2021-12-10 14:53:12.989 | . 1 61b369d876faf969a2fb0aca | user2 | 55 | male | NaT | . 2 61b369d876faf969a2fb0acb | user3 | 43 | male | NaT | . collection.update_one({&quot;name&quot;:&quot;user4&quot;}, {&quot;$set&quot;:{&quot;age&quot;:32}, &quot;$setOnInsert&quot;:{&quot;sex&quot;:&quot;female&quot;}, &quot;$currentDate&quot;:{&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b369d876faf969a2fb0ac9 | user1 | 32 | male | 2021-12-10 14:53:12.989 | . 1 61b369d876faf969a2fb0aca | user2 | 55 | male | NaT | . 2 61b369d876faf969a2fb0acb | user3 | 43 | male | NaT | . 3 61b369d912c824e29e71ed72 | user4 | 32 | female | 2021-12-10 14:53:13.214 | . Bulk updates . Obviously it&#39;s inefficient if the updates/inserts are performed one by one. To improve this, we firstly collect all the &#39;UpdateOne&#39; operations and perform the updates with &#39;bulk_write&#39; like the following. . df_emplyee = df_emplyee.append({&#39;name&#39;:&#39;user5&#39;,&#39;age&#39;: 65, &#39;sex&#39;:&#39;male&#39;},ignore_index=True) updates = [] df_emplyee.apply( lambda row: updates.append( UpdateOne( {&quot;name&quot;: row.get(&quot;name&quot;)}, {&quot;$set&quot;: row.to_dict(), &quot;$currentDate&quot;:{&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True )), axis=1) collection.bulk_write(updates) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b369d876faf969a2fb0ac9 | user1 | 25 | male | 2021-12-10 14:53:13.449 | . 1 61b369d876faf969a2fb0aca | user2 | 55 | male | 2021-12-10 14:53:13.449 | . 2 61b369d876faf969a2fb0acb | user3 | 43 | male | 2021-12-10 14:53:13.450 | . 3 61b369d912c824e29e71ed72 | user4 | 32 | female | 2021-12-10 14:53:13.214 | . 4 61b369d912c824e29e71ed85 | user5 | 65 | male | 2021-12-10 14:53:13.450 | . DataFrame Upsert . Back to our initial requirement, we need to perform the &#39;Upsert&#39; on individual DataFrame row. I created a function df_upsert for this. . def df_upsert(df:DataFrame, collection, keys:[]): def row_query(row, keys ): res = {} for key in keys: res[key] = row.get(key) return res updates = [] df_emplyee.apply( lambda row: updates.append( UpdateOne( row_query(row, keys), {&#39;$set&#39;: row.to_dict(), &quot;$currentDate&quot;:{&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True)), axis=1 ) collection.bulk_write(updates) . Let&#39;s do some testing. Some updates are applied to the df_emplyee. Here are the difference between the df_emplyee and the MongoDB collection. As we see, user6 is added and user1&#39;s age is changed to 20 from 25. Please note user4 doesn&#39;t exist in the df_emplyee, it will not be touched in the collection. . df_emplyee.loc[0,&#39;age&#39;] = 20 df_emplyee = df_emplyee.append({&#39;name&#39;:&#39;user6&#39;,&#39;age&#39;: 37, &#39;sex&#39;:&#39;female&#39;},ignore_index=True) show_collection(collection) display(df_emplyee) . _id name age sex lastModifiedAt . 0 61b369d876faf969a2fb0ac9 | user1 | 25 | male | 2021-12-10 14:53:13.449 | . 1 61b369d876faf969a2fb0aca | user2 | 55 | male | 2021-12-10 14:53:13.449 | . 2 61b369d876faf969a2fb0acb | user3 | 43 | male | 2021-12-10 14:53:13.450 | . 3 61b369d912c824e29e71ed72 | user4 | 32 | female | 2021-12-10 14:53:13.214 | . 4 61b369d912c824e29e71ed85 | user5 | 65 | male | 2021-12-10 14:53:13.450 | . name age sex . 0 user1 | 20 | male | . 1 user2 | 55 | male | . 2 user3 | 43 | male | . 3 user5 | 65 | male | . 4 user6 | 37 | female | . Once we perform the &#39;df_upsert&#39;, we get the expected results. . df_upsert(df_emplyee, collection, [&#39;name&#39;]) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b369d876faf969a2fb0ac9 | user1 | 20 | male | 2021-12-10 14:53:13.813 | . 1 61b369d876faf969a2fb0aca | user2 | 55 | male | 2021-12-10 14:53:13.813 | . 2 61b369d876faf969a2fb0acb | user3 | 43 | male | 2021-12-10 14:53:13.813 | . 3 61b369d912c824e29e71ed72 | user4 | 32 | female | 2021-12-10 14:53:13.214 | . 4 61b369d912c824e29e71ed85 | user5 | 65 | male | 2021-12-10 14:53:13.813 | . 5 61b369d912c824e29e71edaa | user6 | 37 | female | 2021-12-10 14:53:13.813 | . Consolution . In this post I showed some basic operations of MongoDB through Python and made the function df_upsert. The function df_upsert can be polished further, for instance we can do: . Pass a dictionary of mulitiple rows to the function with collection name as key and DataFrame as the value. | Upate strategy: drop &amp; creation or incremental updates? | . This is my first blog and thanks for your reading. .",
            "url": "https://stevenchen521.github.io/blogging/nosql/python/2021/12/09/mogodb_01.html",
            "relUrl": "/nosql/python/2021/12/09/mogodb_01.html",
            "date": " ‚Ä¢ Dec 9, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "üë§Ô∏è About Me",
          "content": "My name is Steven CHEN and I have been working for 12 years. I started from Java and then I shift to SAP. I got the master from City University Hong Kong major in Data Science. Currently I‚Äôm interested in Machine Learning(especially in Financial Market), DevOps and Software archecture(Micro Service). . My contact: Email .",
          "url": "https://stevenchen521.github.io/blogging/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://stevenchen521.github.io/blogging/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
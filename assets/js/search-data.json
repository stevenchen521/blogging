{
  
    
        "post0": {
            "title": "Upsert DataFrame to MongoDB Step by Step",
            "content": "Requirement . Let&#39;s say we have a DataFrame. We want to &#39;upsert&#39;(Insert/update) the MongoDB collection with rows in DataFrame. More specifically, for the rows that don&#39;t exist we do the creation, otherwise the update should be performed. . def show_collection(collection): display(DataFrame([row for row in collection.find()])) . Setup Cloud MongoDB for Free . Setup a free cloud based MongoDB database here. . Connect to the database and create the &#39;test&#39; database and &#39;employee&#39; collection. . DB_NAME = &#39;test&#39; COLLECTION_NAME = &#39;employee&#39; . client = MongoClient(CONN_STR) client.drop_database(DB_NAME) # clear the database db = client[DB_NAME] # switch database collection = db[COLLECTION_NAME] # get the collection . Prepare a test DataFrame df_emplyee that contains three columns: . name | age | sex | . df_emplyee . name age sex . 0 user1 | 25 | male | . 1 user2 | 55 | male | . 2 user3 | 43 | male | . Once the records are inserted to the collection, we get the _id column for every row. &#39;_id&#39; column is a potentially a good shard key used by MongoDB cluster. . collection.insert_many(df_emplyee.to_dict(&quot;records&quot;)) show_collection(collection) . _id name age sex . 0 61b305066dc6466313715b40 | user1 | 25 | male | . 1 61b305066dc6466313715b41 | user2 | 55 | male | . 2 61b305066dc6466313715b42 | user3 | 43 | male | . Update . Let&#39;s do the update. Change the age of user1 to 32 with update_one method. . filter parameter get the rows that need update. | $set flag is to update the columns specified. | $currentDate here is to update lastModifiedAt column with the current time. | . myquery = { &quot;name&quot;: &quot;user1&quot; } newvalues = { &quot;$set&quot;: { &quot;age&quot;: &quot;32&quot; }, &quot;$currentDate&quot;: {&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} } res = collection.update_one(filter=myquery, update=newvalues) . show_collection(collection) . _id name age sex lastModifiedAt . 0 61b305066dc6466313715b40 | user1 | 32 | male | 2021-12-10 07:43:02.596 | . 1 61b305066dc6466313715b41 | user2 | 55 | male | NaT | . 2 61b305066dc6466313715b42 | user3 | 43 | male | NaT | . Upsert . As the name suggests &#39;upsert&#39; means update/insert records based on the specified filters. For intansce, in the following first example, &#39;user1&#39; exists in the collection. The &#39;upsert&#39; performs the update. In the second example, user4 doesn&#39;t exist and it is inserted to the collection. . collection.update_one({&quot;name&quot;:&quot;user1&quot;}, {&quot;$set&quot;:{&quot;age&quot;:32}, &quot;$currentDate&quot;: {&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b305066dc6466313715b40 | user1 | 32 | male | 2021-12-10 07:43:02.813 | . 1 61b305066dc6466313715b41 | user2 | 55 | male | NaT | . 2 61b305066dc6466313715b42 | user3 | 43 | male | NaT | . collection.update_one({&quot;name&quot;:&quot;user4&quot;}, {&quot;$set&quot;:{&quot;age&quot;:32}, &quot;$setOnInsert&quot;:{&quot;sex&quot;:&quot;female&quot;}, &quot;$currentDate&quot;:{&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b305066dc6466313715b40 | user1 | 32 | male | 2021-12-10 07:43:02.813 | . 1 61b305066dc6466313715b41 | user2 | 55 | male | NaT | . 2 61b305066dc6466313715b42 | user3 | 43 | male | NaT | . 3 61b3050712c824e29e5a1755 | user4 | 32 | female | 2021-12-10 07:43:03.016 | . Bulk update . Obviously it&#39;s inefficient if the updates/inserts are performed one by one. To improve this, we firstly collect all the &#39;UpdateOne&#39; operations and perform the updates with &#39;bulk_write&#39; like the following. . df_emplyee = df_emplyee.append({&#39;name&#39;:&#39;user5&#39;,&#39;age&#39;: 65, &#39;sex&#39;:&#39;male&#39;},ignore_index=True) updates = [] df_emplyee.apply( lambda row: updates.append( UpdateOne( {&quot;name&quot;: row.get(&quot;name&quot;)}, {&quot;$set&quot;: row.to_dict(), &quot;$currentDate&quot;:{&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True )), axis=1) collection.bulk_write(updates) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b305066dc6466313715b40 | user1 | 25 | male | 2021-12-10 07:43:03.236 | . 1 61b305066dc6466313715b41 | user2 | 55 | male | 2021-12-10 07:43:03.236 | . 2 61b305066dc6466313715b42 | user3 | 43 | male | 2021-12-10 07:43:03.236 | . 3 61b3050712c824e29e5a1755 | user4 | 32 | female | 2021-12-10 07:43:03.016 | . 4 61b3050712c824e29e5a1769 | user5 | 65 | male | 2021-12-10 07:43:03.236 | . DataFrame Upsert . Back to our initial requirement, we need to perform the &#39;Upsert&#39; on individual DataFrame row. I created a function df_upsert for this. . def df_upsert(df:DataFrame, collection, keys:[]): def row_query(row, keys ): res = {} for key in keys: res[key] = row.get(key) return res updates = [] df_emplyee.apply( lambda row: updates.append( UpdateOne( row_query(row, keys), {&#39;$set&#39;: row.to_dict(), &quot;$currentDate&quot;:{&quot;lastModifiedAt&quot;: { &quot;$type&quot;: &quot;date&quot; }} }, upsert=True)), axis=1 ) collection.bulk_write(updates) . Let&#39;s do some testing. Some updates are applied to the df_emplyee. Here are the difference between the df_emplyee and the MongoDB collection. More specifically, user6 is added and user1&#39;s age is different. . df_emplyee.loc[0,&#39;age&#39;] = 20 df_emplyee = df_emplyee.append({&#39;name&#39;:&#39;user6&#39;,&#39;age&#39;: 37, &#39;sex&#39;:&#39;female&#39;},ignore_index=True) show_collection(collection) display(df_emplyee) . _id name age sex lastModifiedAt . 0 61b305066dc6466313715b40 | user1 | 25 | male | 2021-12-10 07:43:03.236 | . 1 61b305066dc6466313715b41 | user2 | 55 | male | 2021-12-10 07:43:03.236 | . 2 61b305066dc6466313715b42 | user3 | 43 | male | 2021-12-10 07:43:03.236 | . 3 61b3050712c824e29e5a1755 | user4 | 32 | female | 2021-12-10 07:43:03.016 | . 4 61b3050712c824e29e5a1769 | user5 | 65 | male | 2021-12-10 07:43:03.236 | . name age sex . 0 user1 | 20 | male | . 1 user2 | 55 | male | . 2 user3 | 43 | male | . 3 user5 | 65 | male | . 4 user6 | 37 | female | . df_upsert(df_emplyee, collection, [&#39;name&#39;]) show_collection(collection) . _id name age sex lastModifiedAt . 0 61b305066dc6466313715b40 | user1 | 20 | male | 2021-12-10 07:43:03.581 | . 1 61b305066dc6466313715b41 | user2 | 55 | male | 2021-12-10 07:43:03.581 | . 2 61b305066dc6466313715b42 | user3 | 43 | male | 2021-12-10 07:43:03.581 | . 3 61b3050712c824e29e5a1755 | user4 | 32 | female | 2021-12-10 07:43:03.016 | . 4 61b3050712c824e29e5a1769 | user5 | 65 | male | 2021-12-10 07:43:03.581 | . 5 61b3050712c824e29e5a1789 | user6 | 37 | female | 2021-12-10 07:43:03.581 | .",
            "url": "https://stevenchen521.github.io/blogging/nosql/python/2021/12/09/mogodb_01.html",
            "relUrl": "/nosql/python/2021/12/09/mogodb_01.html",
            "date": " • Dec 9, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://stevenchen521.github.io/blogging/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://stevenchen521.github.io/blogging/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}